from ngt import settings
if not settings.DISABLE_GEO:
    from django.contrib.gis.db import models
else:
    from django.db import models
import os, time, hashlib, datetime
import uuid
import json
#from ngt.assets.models import Asset, DATA_ROOT

import logging
logger = logging.getLogger('job_models')

class Job(models.Model):
    uuid = models.CharField(max_length=32, null=True)
    jobset = models.ForeignKey('JobSet', related_name="jobs")
    transaction_id = models.IntegerField(null=True)
    command = models.CharField(max_length=64)
    arguments = models.TextField(default='') # an array seriaized as json
    status = models.CharField(max_length=32, default='new')
    processor = models.CharField(max_length=32, null=True, default=None)
    assets = models.ManyToManyField('assets.Asset', related_name='jobs')
    output = models.TextField(null=True)

    time_started = models.DateTimeField(null=True, default=None)
    time_ended = models.DateTimeField(null=True, default=None)
    pid = models.IntegerField(null=True)
    ended = models.BooleanField(default=False)
    
    dependencies = models.ManyToManyField('Job', symmetrical=False)
    
    creates_new_asset = models.BooleanField(default=False) # if this is set, the dispatcher will create a new asset when the job is completed
    outfile_argument_index = models.SmallIntegerField(default=1) # index of the output filename in the argument list.  Used to generate output asset records.
    
    if not settings.DISABLE_GEO:
            footprint = models.PolygonField(null=True, srid=949900)
    
    def _generate_uuid(self):
        '''Returns a unique job ID that is the MD5 hash of the local
        hostname, the local time of day, and the command & arguments for this job.'''
        return uuid.uuid1().hex
    
    def __unicode__(self):
        return self.command + ' ' + self.uuid

    @property
    def command_string(self):
        return self.command + ' ' + ' '.join(json.loads(self.arguments))
       
            
    def dependencies_met(self):
        ''' 
            Return True if all dependencies are met, False otherwise.
            A dependency is met if the depending job has ended.
        '''
        if self.dependencies.filter(ended=False):
            return False
        else:
            return True
    
        
    def spawn_output_asset(self):
        """ Creates a new asset record for the job's output file. 
            Assumes that the output filename will be the second parameter in the output list
        """
        assert self.assets.count() == 1
        asset_o = self.assets.all()[0]
        asset_n = Asset()
        asset_n.__dict = asset_o.__dict__
        asset_n.id = None
        asset_n.is_original = False
        asset_n.creator_job = self
        args = json.loads(self.arguments)
        asset_n.relative_file_path = args[self.outfile_argument_index].replace(DATA_ROOT,'')
        assert os.path.exists(asset_n.file_path)
        asset_n.class_label = self.jobset.output_asset_label or self.jobset.name
        asset_n.save()
        asset_n.parents.add(asset_o)
        
    
    
def set_uuid(instance, **kwargs):
    if not instance.uuid:
        instance.uuid = instance._generate_uuid()
def set_ended(instance, **kwargs):
    if instance.status in ('complete','failed','ended'):
        instance.ended = True
    else:
        instance.ended = False
models.signals.pre_save.connect(set_uuid, sender=Job)
models.signals.pre_save.connect(set_ended, sender=Job)

class JobSet(models.Model):
    name = models.CharField(max_length=256)
    assets = models.ManyToManyField('assets.Asset') # this collection of assets can be used to populate jobs
    #jobs = models.ManyToManyField(Job, editable=False) # now a foreign key in the Job model
    status = models.CharField(max_length=32, default='new')
    command = models.CharField(max_length=64)
    active = models.BooleanField(default=False)
    priority = models.IntegerField(default=0)
    
    output_asset_label = models.CharField(max_length=256, null=True, default=None) # this is the label that will be applied to assets generated by jobs in this set
    
    def __unicode__(self):
        return "<%d: %s>" % (self.id, self.name)
        
    def simple_populate(self, creates_new_asset=True):
        """ Create one-parameter jobs for each of this batch's assets
            Only really useful for testing.
        """
        print "Creating jobs for %s" % str(self.assets.all())
        for asset in self.assets.all():
            print "About to create a job for %s" % str(asset)
            self.jobs.create(
                command=self.command, 
                arguments='["%s"]' % asset.file_path, #json-decodable lists of one
                creates_new_asset = creates_new_asset,
            )
    
    def execute(self):
        #self.simple_populate()
        self.status = "dispatched"
        for job in self.jobs.filter(status='new'):
            job.enqueue()
    def reset(self):
        self.jobs.update(status='new')

    ####
    # Convenience Methods for jobset wrangling.
    ####
    @classmethod
    def get(klass, jobset):
        if type(jobset) == klass:
            return jobset
        elif type(jobset) == int:
            return klass.objects.get(pk=jobset)
        else:
            raise ArgumentError

    @classmethod
    def activate(klass, jobset):
        js = klass.get(jobset)
        js.active = True
        js.save()
        print "%s activated." % str(js)

    @classmethod
    def deactivate(klass, jobset):
        js = klass.get(jobset)
        js.active = False
        js.save()
        print "%s deactivated." % str(js)
            
def active_jobsets():
    return [(js, js.jobs.count(), js.jobs.filter(status='new').count()) for js in JobSet.objects.filter(active=True)]


from ngt.assets.models import Asset, DATA_ROOT # putting this here helps avoid circular imports

